<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Babylon.js sample code</title>
    <!-- Babylon.js -->
    <script src="hand.minified-1.2.js"></script>
    <script src="babylon.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        if (BABYLON.Engine.isSupported()) {
            var canvas = document.getElementById("renderCanvas");
            var engine = new BABYLON.Engine(canvas, true);

            var createScene = function() {
                var scene = new BABYLON.Scene(engine);
                var meshes = [];
                var camera = new BABYLON.ArcRotateCamera("Camera", 0, Math.PI / 2, 12, BABYLON.Vector3.Zero(), scene);

                camera.attachControl(canvas, false);
                camera.lowerRadiusLimit = 1;
                camera.minZ = 1.0;

                function selectMesh(index) {
                    switch (index) {
                        case 0:
                            // Creating sphere
                            meshes.push(BABYLON.Mesh.CreateSphere("mesh", 16, 5, scene));
                            break;
                        case 1:
                            // Creating Torus
                            meshes.push(BABYLON.Mesh.CreateTorus("mesh", 5, 1, 32, scene));
                            break;
                        case 2:
                            // Creating Torus knot
                            meshes.push(BABYLON.Mesh.CreateTorusKnot("mesh", 2, 0.5, 128, 64, 2, 3, scene));
                            break;
                        case 3:
                            meshes.push(BABYLON.Mesh.CreateGroundFromHeightMap("mesh", "heightMap.png", 8, 8, 100, 0, 3, scene, false));
                            break;
                    }
                };

                BABYLON.Effect.ShadersStore["customVertexShader"]=                "precision highp float;\r\n"+
                "precision highp int;\r\n"+
                "// Attributes\r\n"+
                "//attribute vec3 position;\r\n"+
                "//attribute vec2 uv;\r\n"+
                "// Default attributes provided by THREE.js. Attributes are only available in the\r\n"+
                "// vertex shader. You can pass them to the fragment shader using varyings\r\n"+
                "attribute vec3 position;\r\n"+
                "attribute vec3 normal;\r\n"+
                "attribute vec2 uv;\r\n"+
                "attribute vec2 uv2;\r\n"+



                "// Uniforms\r\n"+
                "uniform mat4 worldViewProjection;\r\n"+
                "uniform mat4 modelMatrix;\r\n"+
                "uniform mat4 modelViewMatrix;\r\n"+
                "uniform mat4 projectionMatrix;\r\n"+
                "uniform mat4 viewMatrix;\r\n"+
                "uniform mat3 normalMatrix;\r\n"+
                "// Default uniforms provided by ShaderFrog.\r\n"+
                "uniform vec3 cameraPosition;\r\n"+
                "uniform float time;\r\n"+

                "// Varying\r\n"+
                "// Examples of variables passed from vertex to fragment shader\r\n"+
                "varying vec3 vPosition;\r\n"+
                "varying vec3 vNormal;\r\n"+
                "varying vec2 vUv;\r\n"+
                "varying vec2 vUv2;\r\n"+
                "void main(void) {\r\n"+
                "    vNormal = normal;\r\n"+
                "    vUv = uv;\r\n"+
                "    vUv2 = uv2;\r\n"+
                "    vPosition = position;\r\n"+

                "    gl_Position = worldViewProjection * vec4(position, 1.0);\r\n"+

                "    vUv = uv;\r\n"+
                "}\r\n";

                BABYLON.Effect.ShadersStore["customFragmentShader"]=                "// Original https://www.shadertoy.com/view/MljSzW - Imported with permission\r\n"+
                "// Created by Stefan Draganov - vortex/2015\r\n"+
                "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n"+

                "precision highp float;\r\n"+
                "precision highp int;\r\n"+

                "uniform vec2 resolution;\r\n"+
                "uniform float time;\r\n"+
                "uniform float speed;\r\n"+
                "uniform float baseRadius;\r\n"+
                "uniform float colorVariation;\r\n"+
                "uniform float brightnessVariation;\r\n"+
                "uniform vec3 backgroundColor;\r\n"+
                "uniform float variation;\r\n"+

                "varying vec2 vUv;\r\n"+

                "vec3 n(vec2 x, float t) {\r\n"+
                "    vec3 v = floor(vec3(x, t));\r\n"+
                "    vec3 u = vec3(mod(v.xy, variation), v.z);\r\n"+
                "    vec3 c = fract( u.xyz * (\r\n"+
                "        vec3(0.16462, 0.84787, 0.98273) +\r\n"+
                "        u.xyz * vec3(0.24808, 0.75905, 0.13898) +\r\n"+
                "        u.yzx * vec3(0.31517, 0.62703, 0.26063) +\r\n"+
                "        u.zxy * vec3(0.47127, 0.58568, 0.37244)\r\n"+
                "    ) + u.yzx * (\r\n"+
                "        vec3(0.35425, 0.65187, 0.12423) +\r\n"+
                "        u.yzx * vec3(0.95238, 0.93187, 0.95213) +\r\n"+
                "        u.zxy * vec3(0.31526, 0.62512, 0.71837)\r\n"+
                "    ) + u.zxy * (\r\n"+
                "        vec3(0.95213, 0.13841, 0.16479) +\r\n"+
                "        u.zxy * vec3(0.47626, 0.69257, 0.19738)\r\n"+
                "    ) );\r\n"+
                "    return v + c;\r\n"+
                "}\r\n"+

                "// Generate a predictably random color based on an input coord\r\n"+
                "vec3 col(vec2 x, float t) {\r\n"+
                "    return vec3(\r\n"+
                "        0.5 + max( brightnessVariation * cos( x.y * x.x ), 0.0 )\r\n"+
                "    ) + clamp(\r\n"+
                "        colorVariation * cos(fract(vec3(x, t)) * 371.0241),\r\n"+
                "        vec3( -0.4 ),\r\n"+
                "        vec3( 1.0 )\r\n"+
                "    );\r\n"+
                "}\r\n"+

                "vec2 idx(vec2 x) {\r\n"+
                "    return floor(fract(x * 29.0) * 3.0) - vec2(1.0);\r\n"+
                "}\r\n"+

                "float circle(vec2 x, vec2 c, float r) {\r\n"+
                "    return max(0.0, 1.0 - dot(x - c, x - c) / (r * r));\r\n"+
                "}\r\n"+

                "void main() {\r\n"+
                "    \r\n"+
                "    vec2 x = vUv * resolution;\r\n"+
                "    float t = time * speed;\r\n"+
                "    vec4 c = vec4(vec3(0.0), 0.1);\r\n"+
                "    \r\n"+
                "    for (int N = 0; N < 3; N++) {\r\n"+
                "        for (int k = -1; k <= 0; k++) {\r\n"+
                "            for (int i = -1; i <= 1; i++) {\r\n"+
                "                for (int j = -1; j <= 1; j++) {\r\n"+
                "                    vec2 X = x + vec2(j, i);\r\n"+
                "                    float t = t + float(N) * 38.0;\r\n"+
                "                    float T = t + float(k);\r\n"+
                "                    vec3 a = n(X, T);\r\n"+
                "                    vec2 o = idx(a.xy);\r\n"+
                "                    vec3 b = n(X + o, T + 1.0);\r\n"+
                "                    vec2 m = mix(a.xy, b.xy, (t - a.z) / (b.z - a.z));\r\n"+
                "                    float r = baseRadius * sin(3.1415927 * clamp((t - a.z) / (b.z - a.z), 0.0, 1.0));\r\n"+
                "                    if (length(a.xy - b.xy) / (b.z - a.z) > 2.0) {\r\n"+
                "                        r = 0.0;\r\n"+
                "                    }\r\n"+
                "                    c += vec4(col(a.xy, a.z), 1.0) * circle(x, m, r);\r\n"+
                "                }\r\n"+
                "            }\r\n"+
                "        }\r\n"+
                "    }\r\n"+
                "    \r\n"+
                "    gl_FragColor = vec4(c.rgb / max(1e-5, c.w) + backgroundColor, 1.0);\r\n"+
                "    \r\n"+
                "}\r\n"+


                selectMesh(2);

                // Compile
                var shaderMaterial = new BABYLON.ShaderMaterial("shader", scene, {
                    vertex: "custom",
                    fragment: "custom",
                },
                    {
                        attributes: ["position", "normal", "uv"],
                        uniforms: ["world", "worldView", "worldViewProjection", "view", "projection"]
                    });

                var refTexture = new BABYLON.Texture("ref.jpg", scene);
                refTexture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;
                refTexture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;

                var mainTexture = new BABYLON.Texture("amiga.jpg", scene);

                shaderMaterial.setTexture("textureSampler", mainTexture);
                shaderMaterial.setTexture("refSampler", refTexture);
                shaderMaterial.setFloat("time", 0);
                shaderMaterial.setVector3("cameraPosition", BABYLON.Vector3.Zero());
                shaderMaterial.backFaceCulling = false;

                for (var index = 0; index < meshes.length; index++) {
                    var mesh = meshes[index];
                    mesh.material = shaderMaterial;
                }

                return scene;
            }

            var scene = createScene();
            var time = 0;
            engine.runRenderLoop(function () {
                var shaderMaterial = scene.getMaterialByName("shader");
                shaderMaterial.setFloat("time", time);
                time += 0.02;

                shaderMaterial.setVector3("cameraPosition", scene.activeCamera.position);

                scene.render();
            });

            window.addEventListener("resize", function () {
                engine.resize();
            });
        }
    </script>
</body>
</html>
